#!/usr/bin/env bash

# TODO: Clean up project file permissions using blanket www-data chown for all project files via deploy script.
# Then finer grained individual file control using application specific post-hooks called by deploy script.
# NOTE: is this still needed now that git pulls with www-data as local file owner?

# TODO:
# /data/available-websites/
# /data/available-websites/celest/code
# /data/available-websites/celest/file-backup
# /data/available-websites/celest/database-backup
#
# If dir is empty or does not exist.
#	Create dir.
# If file-backup dir exists
# 	if git repo exists, then: get git archive (no .git folder)
# 	else, scp folder
# If code dir exists
# 	if git, setup repository and git pull
# 	else, scp folder
# If .config/mysql exists in project
# 	If database-backup dir exists
# 		if git repo exists, get git archive (no .git folder). Deploy. -- To where? .deploy folder somewhere that gets rm'd at the end?
# 		else, scp folder
# 	Execute .config/mysql file based on table version.
# 
# Check backup-code for git, if so "export", in other words pull without .git repo. See:
# http://stackoverflow.com/questions/160608/how-to-do-a-git-export-like-svn-export

this_file=`basename "$0"`
original_dir=`pwd`

project_name=$1
project_dir="/data/websites/${project_name}" # TODO: Pull in this root from puppet variable
project_config_dir="${project_dir}/.config" # TODO: Pull in this root from puppet variable

remote_user="git"
remote_host="compnet-nexus.bu.edu"
remote_path="/data/websites"
remote_port="2222"
git_remote="${remote_user}@${remote_host}:${remote_path}/${project_name}"
# git_remote="${remote_host}:${remote_path}/${project_name}"
# git_remote="ssh://${remote_user}@${remote_host}:${remote_port}/${remote_path}/${project_name}"
# git_remote="ssh://${remote_host}/${remote_path}/${project_name}"
git_branch="deploy"
git_user="www-data"

# option_example_one=
# option_example_two=
# parse_options () {
# 	while getopts "o:t:" opt; do
# 		case $opt in
# 			o)
# 				option_example_one=$OPTARG
# 				;;
# 			t)
# 				option_example_two=$OPTARG
# 				;;
# 		esac
# 	done
# } ; parse_options $@

set -o nounset
set -o errtrace
set -o errexit
set -o pipefail

log () {
	printf "$*\n"
}

error () {
	log "ERROR: " "$*\n"
	exit 1
}

help () {
	echo "Usage is './${this_file} <project-name>'"
}

# Application functions

before_exit () {
	# Works like a finally statement
	# Code that must always be run goes here
	return
} ; trap before_exit EXIT

verify_root_privileges () {
	if [[ $EUID -ne 0 ]]; then
		fail "Requires root privileges."
	fi
}

verify_input () {
	if [[ -z ${project_name} ]] ; then
		help
		exit 1
	fi
}

# Project file functions

_git_clone_repository () {
	if [[ -d "$project_dir/.git" ]] ; then
		log "Notice: " "Repository already setup. Skipping remote git clone."
		return 0
	fi

	mkdir -p "$project_dir"
	chown "$git_user":"$git_user" "$project_dir"

	if ! sudo -u "$git_user" git clone -b $git_branch $git_remote ; then
		error "Could not clone remote code repository."
	fi
}

_git_configure_remote () {
	# Git remote "origin" will be properly set during git clone. This function allows renaming
	# of git remote branch address if it changes.
	set +o nounset
	current_remote=`git remote show -n origin | grep "Fetch URL" | awk -F': ' '{print $2}'`
	set -o nounset

	if [[ "$current_remote" != "$git_remote" ]]; then
		log "Notice:" "Updating git remote. Current remote does not match specified git remote: '${current_remote}' '${git_remote}'"

		if ! git remote rm origin; then
			error "Could not remove old git remote branch origin."
		fi

		if ! sudo -u "$git_user" git remote add -t $git_branch --tags origin $git_remote; then
			error "Could not add new git remote branch origin."
		fi
	fi
}

_git_pull_from_remote () {
	if ! sudo -u "$git_user" git pull origin $git_branch:$git_branch; then
		error "Could not pull git live branch from remote, branch: '${git_branch}'."
	fi
}

_git_checkout_version () {
	# TODO: Add in version, e.g. "${git_branch}~1"
	# NOTE: Do not checkout ${git_branch}~0. Make sure to just do $git_branch if 0.
	if ! sudo -u "$git_user" git checkout $git_branch; then
		error "Could not checkout git live branch locally, branch: '${git_branch}'."
	fi
}

_after_update_application_scripts () {
	# TODO: Once standardized, look into that project folder. E.g.:
	# look into ./.meta/after-file-update/* and execute all shell scripts inside.
	return 0;
}

_reload_if_python_wsgi_app () {
	# Python applications running on Apache/mod_wsgi need to be reloaded after
	# files have been changed. By default WSGIScriptReloading is on, meaning
	# a reload will occur if .wsgi file is touched. 
	wsgi_file=`ls -a | grep --color=never \.wsgi$`
	if [[ -n "$wsgi_file" ]]; then
		if ! touch "$wsgi_file"; then
			error "Found Python .wsgi file, but could not reload it with the touch command: '${wsgi_file}'"
		fi
	fi
}

_after_update_reload_scripts () {
	_reload_if_python_wsgi_app
}

configure_and_update_project_files () {
	_git_clone_repository

	cd "$project_dir"
	_git_configure_remote
	_git_pull_from_remote
	_git_checkout_version
	_after_update_application_scripts
	# _after_update_reload_scripts # Causing deploy script failure
	cd "$original_dir"
}

# Project database functions

# TODO implement dbdeploy scripts and standardize on file location. E.g.:
# point deploy program at ./.config/sql/* and execute scripts depending on current version in the db.

_mysql_import_file () {
	file="$1"
	if [[ ! -f "$file" ]]; then
		error "Could not find file to import into mysql: '${file}'"
	fi

	if [[ ! -f /data/mysql/mysql_envvars.sh ]]; then
		error "Could not source needed mysql environmental variables: '/data/mysql/mysql_envvars.sh'"
	fi

	source /data/mysql/mysql_envvars.sh

	# Note: must have no space between -p and password.
	if ! mysql -u ${mysql_root_user} -p${mysql_root_password} < $file; then
		error "Could not import mysql file: '${file}'"
	fi
}

configure_mysql () {
	if [[ ! -d "${project_config_dir}/mysql" ]]; then
		return 0;
	fi

	for i in `ls "${project_config_dir}/mysql/" | grep import | sort`; do
		_mysql_import_file "${project_config_dir}/mysql/${i}"
	done
}

# Application execution

verify_root_privileges
verify_input
configure_and_update_project_files
configure_mysql
